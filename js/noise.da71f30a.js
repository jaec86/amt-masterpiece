(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["noise"],{"7cec":function(e,t,a){"use strict";a.r(t);var i=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"overflow-scroll scrolling-touch"},[a("div",{staticClass:"container mx-auto"},[a("div",{staticClass:"p-6",style:{minHeight:"calc(100vh - 72px)"}},[a("h1",[e._v("Perlin Noise")]),a("p",[e._v("The world have a certain unpredictability in its textures and motions, generally referred as randomness. But randomness is quite chaotic, while nature have an organic flow. This was elegantly solved by Ken Perlin during the production of the original Tron movie while trying to produce more realistic textures. Perlin noise has a more organic appearance because it produces a naturally ordered and smooth sequence of pseudo-random numbers.")]),e._m(0),e._m(1),e._m(2),e._m(3),a("p",[e._v("This algorithm was improved in 2001 by Perlin himself. Classic noise algorithm for N dimensions smoothly interpolates 2 to the N points. This means that for 2D and 3D it needs to interpolate 4 and 8 points, and this will increase exponentially. But Perlin noticed that instead of using a square to fill a space is more efficient to use an equilateral triangle, which is the simplest 2D shape. The squared grid is replaced by the simplex grid of equillateral triangles, which means that for N dimensions only N + 1 corners are computed. But when dividing a square by two triangles, the resulting triangles are not equilateral but isosceles, so the grid is skewed until every triangle is equilateral.")]),e._m(4),a("br"),a("h2",[e._v("Masterpiece Implementation")]),e._m(5),e._m(6),e._m(7),e._m(8),e._m(9),a("p",[e._v("Above the image on the left side is the result of applying noise in the coordinates of the particles, including the size. On the right side is the result of applying noise to the circle shape of the particle. In the next section some more motion will be included based on the audio frequency.")])]),a("div",{staticClass:"fixed top-0 left-0 w-full pointer-events-none",style:{height:"calc(100vh - 72px)",boxShadow:"inset 0 0 0.75rem 1rem #e2e8f0"}}),a("div",{staticClass:"sticky bottom-0 flex justify-between items-center px-3 py-6 bg-gray-300"},[a("div",{staticClass:"px-3 w-1/3"},[a("router-link",{staticClass:"flex items-center text-gray-600 hover:text-gray-800 focus:text-gray-800 outline-none transition-all duration-500",attrs:{to:"/halftone"}},[a("svg",{staticClass:"inline-block w-4",attrs:{"aria-hidden":"true",focusable:"false","data-prefix":"fad","data-icon":"arrow-left",role:"img",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 448 512"}},[a("g",[a("path",{staticClass:"opacity-50",attrs:{fill:"currentColor",d:"M424 297H137.6L96 256l41.59-41H424c13.3 0 24 11 24 24.63v32.82A24.22 24.22 0 0 1 424 297z"}}),a("path",{attrs:{fill:"currentColor",d:"M201.69 473.48l-.71-.71L7 273.44a25 25 0 0 1 0-34.78L201 39.23a23.38 23.38 0 0 1 33.11-.7c.24.22.47.46.7.7L256.94 62a25.13 25.13 0 0 1-.4 35.18L95.81 256l160.73 158.8a24.94 24.94 0 0 1 .4 35.18l-22.15 22.78a23.38 23.38 0 0 1-33.1.72z"}})])]),a("span",{staticClass:"ml-3 font-bold text-sm uppercase tracking-wide"},[e._v("Halftone")])])],1),a("div",{staticClass:"px-3 w-1/3 text-center"},[a("router-link",{staticClass:"text-gray-600 hover:text-gray-800 focus:text-gray-800 outline-none transition-all duration-500",attrs:{to:"/"}},[a("svg",{staticClass:"inline-block w-6",attrs:{"aria-hidden":"true",focusable:"false","data-prefix":"fad","data-icon":"home-alt",role:"img",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 576 512"}},[a("g",[a("path",{staticClass:"opacity-50",attrs:{fill:"currentColor",d:"M336 463.58v-95.64a16 16 0 0 0-16-16h-64a16 16 0 0 0-16 16v95.71a16 16 0 0 1-15.92 16l-112.08.29a16 16 0 0 1-16-16V300.05L280.39 148.2a12.19 12.19 0 0 1 15.3 0L480 299.94v164a16 16 0 0 1-16 16l-112-.31a16 16 0 0 1-16-16.05z"}}),a("path",{attrs:{fill:"currentColor",d:"M530.92 300.94L295.69 107.2a12.19 12.19 0 0 0-15.3 0L45.17 300.94a12 12 0 0 1-16.89-1.64l-25.5-31a12 12 0 0 1 1.61-16.89l253.1-208.47a48 48 0 0 1 61 0l253.13 208.47a12 12 0 0 1 1.66 16.89l-25.5 31a12 12 0 0 1-16.86 1.64z"}})])])])],1),a("div",{staticClass:"flex flex-row-reverse px-3 w-1/3"},[a("router-link",{staticClass:"flex items-center text-gray-600 hover:text-gray-800 focus:text-gray-800 outline-none transition-all duration-500",attrs:{to:"/sound"}},[a("span",{staticClass:"mr-3 font-bold text-sm uppercase tracking-wide"},[e._v("Sound")]),a("svg",{staticClass:"inline-block w-4",attrs:{"aria-hidden":"true",focusable:"false","data-prefix":"fad","data-icon":"arrow-right",role:"img",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 448 512"}},[a("g",[a("path",{staticClass:"opacity-50",attrs:{fill:"currentColor",d:"M24 215h286.4l41.6 41-41.59 41H24c-13.3 0-24-11-24-24.63v-32.82A24.22 24.22 0 0 1 24 215z"}}),a("path",{attrs:{fill:"currentColor",d:"M246.31 38.52c.24.23.48.47.71.71L441 238.56a25 25 0 0 1 0 34.78L247 472.77a23.38 23.38 0 0 1-33.11.7c-.24-.22-.47-.46-.7-.7L191.06 450a25.13 25.13 0 0 1 .4-35.18L352.19 256 191.46 97.2a24.94 24.94 0 0 1-.4-35.18l22.15-22.78a23.38 23.38 0 0 1 33.1-.72z"}})])])])],1)])])])},n=[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("The main idea behind Perlin noise is to get a normalized value, between "),a("code",[e._v("0.0")]),e._v(" and "),a("code",[e._v("1.0.")]),e._v(", but taking into consideration the previous iteration. Like any regular random function a continuous floating number "),a("code",[e._v("x")]),e._v(" is subdivided into its integer "),a("code",[e._v("i")]),e._v(" and fractional "),a("code",[e._v("f")]),e._v(" values. A regular random function will get a random value for the integer part of "),a("code",[e._v("x")]),e._v(", but Perlin noise interpolates each random value using the fractional "),a("code",[e._v("f")]),e._v(" value.")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[a("pre",{staticClass:"px-6 rounded bg-gray-800 text-sm text-gray-100 overflow-x-scroll scrolling-touch"},[a("code",[e._v("\nfloat noise(float x) {\n  float i = floor(x); "),a("span",{staticClass:"text-gray-600"},[e._v("// integer")]),e._v("\n  float f = fract(x); "),a("span",{staticClass:"text-gray-600"},[e._v("// fractional")]),e._v("\n  return mix(rand(i), rand(i + 1.0), smoothstep(0.0, 1.0, f)); "),a("span",{staticClass:"text-gray-600"},[e._v(" //  smooth interpolation")]),e._v("\n}\n          ")])])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("The function above is a linear implementation of the Perlin Noise algorithm. To get a 2D noise value, instead of interpolating between two points of a line, it interpolates the four corners that compose the area of a plane like ("),a("code",[e._v("fract(st)")]),e._v(", "),a("code",[e._v("fract(st) + vec2(1.0, 0.0)")]),e._v(", "),a("code",[e._v("fract(st) + vec2(0.0, 1.0)")]),e._v(" and "),a("code",[e._v("fract(st) + vec2(1.0, 1.0)")]),e._v("). The same goes for 3D, noise where it interpolates between the eight cornes of a cube. This technique is all about interpolating random values.")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[a("img",{staticClass:"mx-auto",attrs:{src:"images/3d_noise.png",alt:"3D Interpolation"}})])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[a("img",{staticClass:"mx-auto",attrs:{src:"images/simplex_grid.png",alt:"Simplex Grid"}})])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("In the vertex shader the "),a("code",[e._v("x")]),e._v(" and "),a("code",[e._v("y")]),e._v(" coordinates are updated to include some noise, making the particles move slightly from its original position. The "),a("code",[e._v("z")]),e._v(" coordinate is also updated with some 2D noise but instead using the time. Manipulating slightly the "),a("code",[e._v("z")]),e._v(" value with the grayscale value of the pixel will also give the illusion of scaling of the particle size. "),a("a",{attrs:{href:"https://github.com/glslify/glslify",target:"_blank"}},[e._v("Glslify")]),e._v(" library is used to import the simplex 2D noise function into the shaders.")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[a("pre",{staticClass:"px-6 rounded bg-gray-800 text-sm text-gray-100 overflow-x-scroll scrolling-touch"},[a("code",[e._v("\n"),a("span",{staticClass:"text-gray-600"},[e._v("// vertex shader")]),e._v("\nprecision highp float;\n\nattribute vec2 uv;\nattribute vec3 position;\nattribute vec3 offset;\nattribute float pindex;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform vec2 uTextureSize;\nuniform float uSize;\nuniform float uTime;\nuniform float uRandom;\nuniform float uDepth;\n\nvarying vec2 vPUv;\nvarying vec2 vUv;\n\n#pragma glslify: snoise2 = require(glsl-noise/simplex/2d)\n\nfloat random(float n) {\n  return fract(sin(n) * 43758.5453123);\n}\n\nvoid main {\n  vUv = uv;\n  vPUv = offset.xy / uTextureSize;\n\n  vec4 originalColor = texture2D(uTexture, vPUv);\n  float gray = originalColor.r * 0.21 + originalColor.g * 0.71 + originalColor.b * 0.07;\n\n  vec3 displaced = offset;\n  displaced.xy += snoise2(vec2(displaced)) * 2.0;\n  displaced.xy -= uTextureSize * 0.5;\n\n  vec4 mvPosition = modelViewMatrix * vec4(displaced, 1.0);\n  mvPosition.xyz += position * uSize;\n\n  float randomZ = random(pindex) + snoise2(vec2(pindex * 0.1, uTime * 0.1));\n  displaced.z += randomZ * random(pindex) * 2.0 * uDepth;\n\n  float pSize = snoise2(vec2(uTime, pindex) * 0.5) + 2.0;\n  pSize *= max(gray, 0.2);\n  pSize *= uSize;\n\n  vec4 mvPosition = modelViewMatrix * vec4(displaced, 1.0);\n  mvPosition.xyz += position * pSize;\n\n  gl_Position = vec4(projectionMatrix * mvPosition);\n}\n          ")])])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("Because the size of the particle is set on the vertex shader it can be removed from the fragment shader now. To get a more interesting result, the shape of the circle can include some noise. This will result in a dynamic shape of the particle. The function used is a modified version of one of the examples from the "),a("a",{attrs:{href:"https://thebookofshaders.com/",target:"_blank"}},[e._v("Book of Shaders")]),e._v(".")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[a("pre",{staticClass:"px-6 rounded bg-gray-800 text-sm text-gray-100 overflow-x-scroll scrolling-touch"},[a("code",[e._v("\n"),a("span",{staticClass:"text-gray-600"},[e._v("// fragment shader")]),e._v("\nprecision highp float;\n\nuniform sampler2D uTexture;\n\nvarying vec2 vPUv;\nvarying vec2 vUv;\n\n#pragma glslify: snoise2 = require(glsl-noise/simplex/2d)\n\nfloat noiseCircle (vec2 st, float radius) {\n  st = vec2(0.5) - st;\n\n  float r = length(st) * 2.0;\n  float a = atan(st.y, st.x);\n  float m = abs(mod(a + uTime * 2.0, 3.14 * 2.0) - 3.14) / 3.6;\n  float f = radius;\n\n  m += snoise2(st + uTime * 0.1) * 0.5;\n  f += sin(a * 50.0) * snoise2(st + uTime * 0.2) * 0.1;\n  f += (sin(a * 20.0) * 0.1 * pow(m, 2.0));\n\n  return 1.0 - smoothstep(f, f + 0.007, r);\n}\n\nvoid main {\n  vec4 originalColor = texture2D(uTexture, vPUv);\n  float gray = originalColor.r * 0.21 + originalColor.g * 0.71 + originalColor.b * 0.07;\n\n  float alpha = noiseCircle(vUv, 0.6);\n\n  gl_FragColor = vec4(vec3(gray), alpha);\n}\n          ")])])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",{staticClass:"flex items-center mx-auto max-w-screen-lg"},[a("img",{staticClass:"mx-auto w-1/2",attrs:{src:"images/result3_1.jpg"}}),a("img",{staticClass:"mx-auto w-1/2",attrs:{src:"images/result3-2.jpg"}})])}],o=a("2877"),s={},r=Object(o["a"])(s,i,n,!1,null,null,null);t["default"]=r.exports}}]);
//# sourceMappingURL=noise.da71f30a.js.map